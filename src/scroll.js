/* === LICENSE-HEADER START ===
This file is part of "portafolio-tailwind".
Code license: see LICENSE-CODE
Content license: see LICENSE-CONTENT
Â© 2025. See license files for full terms.
Generated by scripts/apply-license-headers.mjs
=== LICENSE-HEADER END === */

/**
 * Grade 3: Tailwind + Modular GSAP Portfolio Scroll Implementation
 * Refactored for hash-based router integration
 *
 * This module provides scroll animations and navigation functionality
 * that can be initialized when a view is mounted and cleaned up when navigating away.
 */
import gsap from 'gsap';
import { ScrollToPlugin } from 'gsap/ScrollToPlugin';
import { ScrollTrigger } from 'gsap/ScrollTrigger';

// Register GSAP plugins once at module load
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

// ==========================================================================
// 1. Configuration
// ==========================================================================

const config = {
	reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
	breakpoints: {
		sm: 640,
		md: 768,
		lg: 1024,
	},
};

// ==========================================================================
// 2. Animation Module
// ==========================================================================

const animations = {
	/**
	 * Initialize GSAP animations within a container element
	 * @param {HTMLElement} container - The container element to scope animations to
	 */
	init(container = document) {
		if (config.reducedMotion) {
			console.log('âš ï¸ Reduced motion preference detected â€” animations disabled');
			this.showAllElements(container);
			return;
		}

		this.initFadeUp(container);
		this.initParallax(container);
		this.initProjectCards(container);

		console.log('âœ¨ Animations initialized');
	},

	/**
	 * Show all animated elements immediately (for reduced motion)
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	showAllElements(container) {
		container.querySelectorAll('[data-animate]').forEach((el) => {
			el.style.opacity = '1';
			el.style.transform = 'none';
		});
	},

	/**
	 * Fade-up animations for elements with data-animate="fade-up"
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initFadeUp(container) {
		const elements = gsap.utils.toArray(container.querySelectorAll('[data-animate="fade-up"]'));

		elements.forEach((el) => {
			// Set initial state
			gsap.set(el, { opacity: 0, y: 40 });

			gsap.to(el, {
				opacity: 1,
				y: 0,
				duration: 0.8,
				ease: 'power2.out',
				scrollTrigger: {
					trigger: el,
					start: 'top 85%',
					toggleActions: 'play none none none',
				},
			});
		});
	},

	/**
	 * Parallax effect for elements with data-parallax attribute
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initParallax(container) {
		const parallaxElements = container.querySelectorAll('[data-parallax]');

		parallaxElements.forEach((el) => {
			const speed = parseFloat(el.dataset.parallax) || 0.2;

			gsap.to(el, {
				yPercent: -100 * speed,
				ease: 'none',
				scrollTrigger: {
					trigger: el.parentElement,
					start: 'top bottom',
					end: 'bottom top',
					scrub: true,
				},
			});
		});
	},

	/**
	 * Staggered reveal for project cards
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initProjectCards(container) {
		// Set initial state explicitly for consistent starting position
		const cards = gsap.utils.toArray(container.querySelectorAll('.project-card'));
		gsap.set(cards, { y: 50, opacity: 0 });

		ScrollTrigger.batch(container.querySelectorAll('.project-card'), {
			onEnter: (batch) => {
				gsap.to(batch, {
					y: 0,
					opacity: 1,
					duration: 0.7,
					stagger: 0.12,
					ease: 'power2.out',
				});
			},
			start: 'top 90%',
			once: true,
		});
	},

	/**
	 * Cleanup all ScrollTrigger instances and animations
	 */
	destroy() {
		ScrollTrigger.getAll().forEach((trigger) => trigger.kill());
		gsap.killTweensOf('*');
	},
};

// ==========================================================================
// 3. Navigation Module
// ==========================================================================

const navigation = {
	navbar: null,
	mobileMenuBtn: null,
	mobileMenu: null,
	scrollIndicator: null,
	eventListeners: [],
	initialized: false,

	/**
	 * Initialize navigation features within a container
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	init(container = document) {
		// Navbar is in the main document, not in the container
		this.navbar = document.getElementById('navbar');
		this.mobileMenuBtn = document.getElementById('mobile-menu-btn');
		this.mobileMenu = document.getElementById('mobile-menu');
		this.menuOverlay = document.getElementById('menu-overlay');
		this.menuIcon = document.getElementById('menu-icon');
		this.closeIcon = document.getElementById('close-icon');
		this.scrollIndicator = container.querySelector('.scroll-indicator');
		this.homeToggle = document.getElementById('home-toggle');
		this.homeSectionsMenu = document.getElementById('home-sections-menu');

		// Initialize menu functionality only once (works on all routes)
		if (!this.initialized) {
			this.initScrollBehavior();
			this.initMobileMenu();
			this.initHomeSectionsMenu();
			this.initialized = true;
		}

		// Only initialize scroll-related features if container has scroll content
		const hasScrollContent = container.querySelector('section[id]') || container.querySelector('.scroll-indicator');
		if (hasScrollContent) {
			this.initScrollIndicator(container);
			this.initSmoothScroll(container);
			this.initActiveState(container);
		} else {
			// Still handle smooth scroll for section links even if no scroll content
			this.initSmoothScroll(container);
		}

		console.log('ðŸ§­ Navigation initialized');
	},

	/**
	 * Navbar background change on scroll
	 */
	initScrollBehavior() {
		if (!this.navbar) return;

		// Navbar is always opaque, but we can add shadow on scroll for depth
		ScrollTrigger.create({
			start: 'top -100',
			onUpdate: (self) => {
				// Add shadow when scrolled for visual depth
				if (self.scroll() > 100) {
					this.navbar.classList.add('shadow-lg');
					this.navbar.classList.remove('shadow-sm');
				} else {
					this.navbar.classList.remove('shadow-lg');
					this.navbar.classList.add('shadow-sm');
				}
			},
		});
	},

	/**
	 * Close mobile menu (helper method)
	 */
	closeMobileMenu() {
		if (!this.mobileMenu) return;
		this.mobileMenu.classList.add('translate-x-full');
		this.menuOverlay?.classList.remove('opacity-100', 'visible', 'pointer-events-auto');
		this.menuOverlay?.classList.add('opacity-0', 'invisible', 'pointer-events-none');
		this.menuIcon?.classList.remove('hidden');
		this.closeIcon?.classList.add('hidden');
		this.mobileMenuBtn?.setAttribute('aria-expanded', 'false');
		document.body.style.overflow = '';
		// Close nested menus
		if (this.homeSectionsMenu) {
			this.homeSectionsMenu.classList.add('hidden');
			this.homeToggle?.setAttribute('aria-expanded', 'false');
			const arrow = this.homeToggle?.querySelector('svg');
			if (arrow) {
				arrow.style.transform = 'rotate(0deg)';
			}
		}
	},

	/**
	 * Mobile menu toggle with slide animation
	 */
	initMobileMenu() {
		if (!this.mobileMenuBtn || !this.mobileMenu) return;

		// Check if already initialized to prevent duplicate listeners
		if (this.mobileMenuBtn.dataset.initialized === 'true') return;
		this.mobileMenuBtn.dataset.initialized = 'true';

		const openMenu = () => {
			this.mobileMenu.classList.remove('translate-x-full');
			this.menuOverlay?.classList.remove('opacity-0', 'invisible', 'pointer-events-none');
			this.menuOverlay?.classList.add('opacity-100', 'visible', 'pointer-events-auto');
			this.menuIcon?.classList.add('hidden');
			this.closeIcon?.classList.remove('hidden');
			this.mobileMenuBtn?.setAttribute('aria-expanded', 'true');
			document.body.style.overflow = 'hidden'; // Prevent body scroll
		};

		const closeMenu = () => {
			this.closeMobileMenu();
		};

		const toggleHandler = () => {
			const isOpen = !this.mobileMenu.classList.contains('translate-x-full');
			if (isOpen) {
				closeMenu();
			} else {
				openMenu();
			}
		};

		this.mobileMenuBtn.addEventListener('click', toggleHandler);
		this.eventListeners.push({ element: this.mobileMenuBtn, event: 'click', handler: toggleHandler });

		// Close menu when clicking overlay
		if (this.menuOverlay) {
			this.menuOverlay.addEventListener('click', closeMenu);
			this.eventListeners.push({ element: this.menuOverlay, event: 'click', handler: closeMenu });
		}

		// Close menu when clicking router links (not section links)
		this.mobileMenu.querySelectorAll('a[href^="#/"]').forEach((link) => {
			link.addEventListener('click', closeMenu);
			this.eventListeners.push({ element: link, event: 'click', handler: closeMenu });
		});

		// Close menu on escape key
		const escapeHandler = (e) => {
			if (e.key === 'Escape' && !this.mobileMenu.classList.contains('translate-x-full')) {
				closeMenu();
			}
		};
		document.addEventListener('keydown', escapeHandler);
		this.eventListeners.push({ element: document, event: 'keydown', handler: escapeHandler });
	},

	/**
	 * Initialize home sections submenu toggle
	 */
	initHomeSectionsMenu() {
		if (!this.homeToggle || !this.homeSectionsMenu) return;

		// Check if already initialized to prevent duplicate listeners
		if (this.homeToggle.dataset.initialized === 'true') return;
		this.homeToggle.dataset.initialized = 'true';

		const toggleHandler = (e) => {
			e.preventDefault();
			const isExpanded = this.homeToggle.getAttribute('aria-expanded') === 'true';
			const arrow = this.homeToggle.querySelector('svg');

			if (isExpanded) {
				this.homeSectionsMenu.classList.add('hidden');
				this.homeToggle.setAttribute('aria-expanded', 'false');
				if (arrow) {
					arrow.style.transform = 'rotate(0deg)';
				}
			} else {
				this.homeSectionsMenu.classList.remove('hidden');
				this.homeToggle.setAttribute('aria-expanded', 'true');
				if (arrow) {
					arrow.style.transform = 'rotate(90deg)';
				}
			}
		};

		this.homeToggle.addEventListener('click', toggleHandler);
		this.eventListeners.push({ element: this.homeToggle, event: 'click', handler: toggleHandler });

		// Close submenu when clicking a section link
		this.homeSectionsMenu.querySelectorAll('a').forEach((link) => {
			const closeHandler = () => {
				// Don't close the main menu, just navigate
				// The main menu will close automatically when section link is clicked
			};
			link.addEventListener('click', closeHandler);
			this.eventListeners.push({ element: link, event: 'click', handler: closeHandler });
		});
	},

	/**
	 * Makes the hero scroll indicator clickable to scroll to the next section
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initScrollIndicator(container) {
		if (!this.scrollIndicator) return;

		// Find the next section after hero (try #about first, then #features, then first section after hero)
		let nextSection = container.querySelector('#about') || container.querySelector('#features');
		if (!nextSection) {
			const hero = container.querySelector('#hero');
			if (hero) {
				const allSections = container.querySelectorAll('section[id]');
				const heroIndex = Array.from(allSections).indexOf(hero);
				if (heroIndex >= 0 && heroIndex < allSections.length - 1) {
					nextSection = allSections[heroIndex + 1];
				}
			}
		}
		if (!nextSection) return;

		// Make it visually interactive
		this.scrollIndicator.style.cursor = 'pointer';
		this.scrollIndicator.setAttribute('role', 'button');
		const sectionName = nextSection.id || 'next section';
		this.scrollIndicator.setAttribute('aria-label', `Scroll to ${sectionName} section`);
		this.scrollIndicator.setAttribute('tabindex', '0');

		/**
		 * Scroll to the next section using GSAP ScrollToPlugin
		 */
		const scrollToNext = () => {
			// Account for main navbar height
			const navHeight = this.navbar?.offsetHeight || 80;

			if (config.reducedMotion) {
				// Instant scroll for reduced motion preference
				window.scrollTo({
					top: nextSection.offsetTop - navHeight,
					behavior: 'auto',
				});
			} else {
				gsap.to(window, {
					duration: 0.8,
					scrollTo: { y: nextSection, offsetY: navHeight },
					ease: 'power2.inOut',
				});
			}
		};

		// Handle click
		this.scrollIndicator.addEventListener('click', scrollToNext);
		this.eventListeners.push({ element: this.scrollIndicator, event: 'click', handler: scrollToNext });

		// Handle keyboard (Enter/Space) for accessibility
		const keyHandler = (e) => {
			if (e.key === 'Enter' || e.key === ' ') {
				e.preventDefault();
				scrollToNext();
			}
		};
		this.scrollIndicator.addEventListener('keydown', keyHandler);
		this.eventListeners.push({ element: this.scrollIndicator, event: 'keydown', handler: keyHandler });
	},

	/**
	 * Smooth scroll for anchor links (both in container and navbar section links)
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initSmoothScroll(container) {
		// Handle section navigation links in the menu
		document.querySelectorAll('.section-nav-link').forEach((anchor) => {
			const clickHandler = (e) => {
				const targetId = anchor.getAttribute('href');
				// Skip router links (#/) and empty anchors
				if (targetId === '#' || targetId.startsWith('#/')) return;

				e.preventDefault();

				// Check if we're on the home route
				const currentRoute = window.location.hash.slice(1) || '/';
				const isHomeRoute = currentRoute === '/' || currentRoute.startsWith('/#');

				if (isHomeRoute) {
					// Already on home route - just scroll to section
					const target = container.querySelector(targetId) || document.querySelector(targetId);
					if (target) {
						const navHeight = this.navbar?.offsetHeight || 80;

						if (config.reducedMotion) {
							window.scrollTo({
								top: target.offsetTop - navHeight,
								behavior: 'auto',
							});
						} else {
							gsap.to(window, {
								duration: 0.8,
								scrollTo: { y: target, offsetY: navHeight },
								ease: 'power2.inOut',
							});
						}

						// Update URL to include section
						history.pushState(null, '', `#/${targetId}`);
					}
				} else {
					// Not on home route - navigate to home first, then scroll
					// Use format: #/#section so router can handle it
					window.location.hash = `#/${targetId}`;
				}

				// Close mobile menu if open
				this.closeMobileMenu();
			};

			anchor.addEventListener('click', clickHandler);
			this.eventListeners.push({ element: anchor, event: 'click', handler: clickHandler });
		});

		// Handle anchor links within the container (like buttons in hero section)
		container.querySelectorAll('a[href^="#"]').forEach((anchor) => {
			// Skip if already handled as section-nav-link
			if (anchor.classList.contains('section-nav-link')) return;

			const clickHandler = (e) => {
				const targetId = anchor.getAttribute('href');
				// Skip router links (#/) and empty anchors
				if (targetId === '#' || targetId.startsWith('#/')) return;

				const target = container.querySelector(targetId) || document.querySelector(targetId);
				if (target) {
					e.preventDefault();

					// Account for main navbar height
					const navHeight = this.navbar?.offsetHeight || 80;

					if (config.reducedMotion) {
						// Instant scroll for reduced motion
						window.scrollTo({
							top: target.offsetTop - navHeight,
							behavior: 'auto',
						});
					} else {
						gsap.to(window, {
							duration: 0.8,
							scrollTo: { y: target, offsetY: navHeight },
							ease: 'power2.inOut',
						});
					}

					// Update URL hash (but not full navigation)
					history.pushState(null, '', targetId);
				}
			};

			anchor.addEventListener('click', clickHandler);
			this.eventListeners.push({ element: anchor, event: 'click', handler: clickHandler });
		});
	},

	/**
	 * Active nav link based on scroll position
	 * @param {HTMLElement} container - The container element to scope queries to
	 */
	initActiveState(container) {
		const sections = container.querySelectorAll('section[id]');
		const sectionNavLinks = container.querySelectorAll('.section-nav-link');
		const routerNavLinks = document.querySelectorAll('.nav-link[href^="#/"]');

		if (sections.length === 0) return;

		sections.forEach((section) => {
			ScrollTrigger.create({
				trigger: section,
				start: 'top center',
				end: 'bottom center',
				onEnter: () => this.setActiveSectionLink(section.id),
				onEnterBack: () => this.setActiveSectionLink(section.id),
			});
		});
	},

	setActiveSectionLink(sectionId) {
		// Update section navigation links (in dropdown)
		document.querySelectorAll('.section-nav-link').forEach((link) => {
			if (link.getAttribute('href') === `#${sectionId}`) {
				link.classList.add('text-primary', 'font-semibold');
				link.classList.remove('text-muted-foreground');
			} else {
				link.classList.remove('text-primary', 'font-semibold');
				link.classList.add('text-muted-foreground');
			}
		});
	},

	/**
	 * Cleanup event listeners and restore body scroll
	 * Note: Menu functionality is preserved across routes, only scroll features are cleaned up
	 */
	destroy() {
		// Only cleanup scroll-related event listeners, not menu functionality
		// Menu should persist across routes
		const scrollListeners = this.eventListeners.filter(
			({ element }) => element.classList?.contains('scroll-indicator') || element.classList?.contains('section-nav-link')
		);

		scrollListeners.forEach(({ element, event, handler }) => {
			element.removeEventListener(event, handler);
		});

		// Remove scroll listeners from the array
		this.eventListeners = this.eventListeners.filter(
			({ element }) => !element.classList?.contains('scroll-indicator') && !element.classList?.contains('section-nav-link')
		);

		// Restore body scroll if menu was open (but don't close menu - it should persist)
		document.body.style.overflow = '';
	},
};

// ==========================================================================
// 4. Public API for Router Integration
// ==========================================================================

/**
 * Initialize scroll animations and navigation for a view
 * @param {HTMLElement} container - The container element (typically the app element)
 */
export function initScrollView(container) {
	// Scroll to top when view loads
	window.scrollTo({ top: 0, behavior: 'auto' });

	// Initialize animations
	animations.init(container);

	// Initialize navigation (menu is initialized globally, but scroll features are per-view)
	navigation.init(container);

	// Refresh ScrollTrigger after a short delay to ensure DOM is ready
	// and after images load
	setTimeout(() => {
		ScrollTrigger.refresh();
	}, 100);

	window.addEventListener(
		'load',
		() => {
			ScrollTrigger.refresh();
		},
		{ once: true }
	);

	console.log('ðŸš€ Scroll view initialized');
}

/**
 * Cleanup scroll animations and navigation when leaving the view
 */
export function cleanupScrollView() {
	animations.destroy();
	// Don't destroy navigation - it should persist across routes
	// navigation.destroy();
	console.log('ðŸ§¹ Scroll view cleaned up');
}

/**
 * Initialize navigation menu (should be called once globally)
 */
export function initNavigation() {
	navigation.init(document);
	console.log('ðŸ§­ Navigation menu initialized');
}
